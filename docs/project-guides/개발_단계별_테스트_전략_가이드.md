# 🧪 Mind Palette 개발 단계별 테스트 전략 가이드

본 문서는 **Mind Palette** 프로젝트의 개발 로드맵(Frontend → Node.js → C++ → Python)에 따라, 각 모듈별로 효과적인 테스트 및 TDD 적용 방법을 정리한 가이드입니다.

---

## 1. Phase 1: Frontend (React + TypeScript)
**목표**: 11월 ~ 1월 (프로토타입 UI 완성)

프론트엔드 개발 시에는 **UI 렌더링**, **사용자 상호작용**, **Mock API 연동**을 중점적으로 테스트합니다.

### 🛠️ 테스트 도구
- **Test Runner**: Jest (Vitest 권장 for Vite)
- **DOM Testing**: React Testing Library (RTL)
- **E2E (선택)**: Cypress or Playwright (후반부 도입 권장)

### ✅ 주요 테스트 시나리오 (TDD 접근)

#### 1. 컴포넌트 단위 테스트 (Unit Test)
- **로그인/회원가입 폼**:
  - 입력값 유효성 검사 로직 테스트 (이메일 형식, 비밀번호 길이 등).
  - 잘못된 입력 시 에러 메시지 노출 여부 확인.
- **이미지 업로드 컴포넌트**:
  - 파일 선택 시 미리보기 이미지가 렌더링되는지 확인.
  - 허용되지 않는 확장자/용량 파일 업로드 시 차단 로직 테스트.
- **결과 시각화 (Chart.js/Canvas)**:
  - 데이터(Props)가 주어졌을 때 차트 컴포넌트가 에러 없이 렌더링되는지 확인.

#### 2. 통합 테스트 (Integration Test)
- **페이지 흐름**:
  - `Upload Page` -> `Loading Page` -> `Result Page` 로의 라우팅 전환 테스트.
- **Mock API 연동**:
  - 백엔드가 없으므로 `MSW (Mock Service Worker)` 또는 `Jest Spy`를 사용하여 API 응답을 모킹(Mocking)합니다.
  - **Case**: 분석 요청 성공 시 로딩 상태(`isLoading: true`)로 변경되고, 완료 후 결과 페이지로 이동하는지 검증.

```typescript
// 예시: 업로드 버튼 클릭 테스트
test('이미지 업로드 후 분석 요청을 보내고 로딩 화면을 보여준다', async () => {
  render(<UploadPage />);
  const fileInput = screen.getByLabelText(/이미지 선택/i);
  const submitBtn = screen.getByRole('button', { name: /분석 시작/i });

  // 1. 파일 업로드 시뮬레이션
  await userEvent.upload(fileInput, fakeFile);
  
  // 2. 버튼 클릭
  await userEvent.click(submitBtn);

  // 3. 로딩 컴포넌트 출현 확인
  expect(screen.getByText(/분석 중입니다/i)).toBeInTheDocument();
});
```

---

## 2. Phase 2: API Gateway (Node.js + Express)
**목표**: 2월 (파일 시스템 기반 백엔드)

데이터베이스 없이 **파일 시스템(fs)**을 사용하므로, 파일의 생성/읽기/삭제와 HTTP 요청/응답 규격을 검증합니다.

### 🛠️ 테스트 도구
- **Unit/Integration**: Jest
- **HTTP Assertion**: Supertest

### ✅ 주요 테스트 시나리오

#### 1. API 엔드포인트 테스트 (Integration)
- **POST /api/upload**:
  - `multipart/form-data` 형식으로 이미지를 전송했을 때 `200 OK`와 함께 업로드된 파일 경로가 반환되는지 확인.
  - 파일이 없는 요청에 대해 `400 Bad Request` 반환 확인.
- **GET /api/result/:id**:
  - 특정 ID 요청 시 JSON 결과 파일 내용을 올바르게 읽어오는지 확인.

#### 2. 파일 시스템 로직 테스트 (Unit)
- **저장소 검증**:
  - 업로드 후 실제로 `./uploads` 폴더에 파일이 생성되었는지 `fs.existsSync`로 검증.
  - 분석 결과 JSON 파일이 `./results` 폴더에 올바른 스키마로 저장되는지 검증.

```javascript
// 예시: Supertest를 이용한 업로드 테스트
describe('POST /api/analyze', () => {
  it('이미지를 업로드하면 파일 경로를 반환해야 한다', async () => {
    const res = await request(app)
      .post('/api/analyze')
      .attach('image', 'test/fixtures/sample_drawing.jpg'); // 테스트용 이미지

    expect(res.statusCode).toEqual(200);
    expect(res.body).toHaveProperty('imagePath');
    expect(res.body).toHaveProperty('score'); // 더미 데이터 확인
  });
});
```

---

## 3. Phase 3: Preprocessing Server (C++)
**목표**: 3월 (고성능 이미지 처리)

OpenCV 알고리즘의 정확성과 스레드 풀의 안정성, 그리고 Crow 웹 서버의 응답을 테스트합니다.

### 🛠️ 테스트 도구
- **Unit Test**: GoogleTest (GTest)
- **Build**: CMake + CTest

### ✅ 주요 테스트 시나리오

#### 1. 알고리즘 단위 테스트 (Unit Test)
- **이미지 처리 함수**:
  - `resize()`: 입력 이미지가 512x512 픽셀로 정확히 변환되는지 `img.rows`, `img.cols` 확인.
  - `grayscale()`: 변환 후 채널 수가 3(RGB)에서 1(Gray)로 변경되었는지 확인.
  - **Golden Master Testing**: 원본 이미지와 "기대되는 결과 이미지(Golden Master)"를 미리 저장해두고, 픽셀 단위로 차이가 허용 오차 이내인지 비교.

#### 2. 스레드 풀 & 성능 테스트
- **동시성 테스트**:
  - 스레드 풀에 100개의 작업을 동시에 넣었을 때 Deadlock 없이 모두 완료되는지 검증.
- **성능 벤치마크**:
  - 이미지 1장 처리 시간이 목표치(< 100ms) 이내인지 측정하는 테스트 케이스 작성.

```cpp
// 예시: GTest를 이용한 리사이징 테스트
TEST(ImageProcessorTest, ResizeCheck) {
    cv::Mat input = cv::imread("test_input.jpg");
    cv::Mat output = ImageProcessor::resize(input, 512, 512);

    EXPECT_EQ(output.cols, 512);
    EXPECT_EQ(output.rows, 512);
    EXPECT_FALSE(output.empty());
}
```

---

## 4. Phase 4: AI Inference Server (Python)
**목표**: 4~5월 (AI 모델 서빙)

FastAPI의 엔드포인트와 PyTorch 모델의 추론 로직(입출력 텐서 형태)을 테스트합니다.

### 🛠️ 테스트 도구
- **Framework**: PyTest
- **API Test**: FastAPI TestClient

### ✅ 주요 테스트 시나리오

#### 1. 모델 단위 테스트 (Model Test)
- **Input/Output Shape**:
  - 모델에 `(Batch, 3, 512, 512)` 텐서를 넣었을 때 출력 텐서의 Shape가 예상과 일치하는지 확인.
- **Sanity Check**:
  - 임의의 더미 데이터(Random noise)를 넣었을 때 에러 없이 결과가 나오는지 확인.

#### 2. API 통합 테스트
- **POST /predict**:
  - 전처리된 이미지 경로를 JSON으로 보냈을 때, `score`와 `features` 키가 포함된 JSON을 반환하는지 확인.
  - GPU/CPU 모드 전환 설정이 올바르게 작동하는지 확인.

```python
# 예시: FastAPI TestClient 테스트
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_predict_endpoint():
    # 실제 파일 대신 Mocking된 경로 전송
    payload = {"image_path": "/shared/processed/test_img.jpg"}
    response = client.post("/predict", json=payload)
    
    assert response.status_code == 200
    data = response.json()
    assert "score" in data
    assert isinstance(data["score"], int)
```

---

## 5. Phase 5 & 6: Integration & E2E (전체 통합)
**목표**: 6~7월 (시스템 통합 및 품질 보증)

Docker Compose로 모든 컨테이너를 띄운 상태에서 전체 흐름을 검증합니다.

### 🛠️ 테스트 도구
- **API Scenario**: Postman + Newman (CLI 실행)
- **Full Stack**: 수동 테스트 또는 Cypress

### ✅ 통합 테스트 시나리오
1. **Happy Path (정상 흐름)**:
   - Frontend에서 이미지 업로드
   - Node.js가 받아서 `./shared/uploads`에 저장
   - Node.js -> C++ 요청 (전처리)
   - C++ -> `./shared/processed` 저장 후 응답
   - Node.js -> Python 요청 (추론)
   - Python -> 결과 JSON 반환
   - Frontend -> 결과 화면 출력
   - **검증**: 최종적으로 Frontend에 점수가 표시되는지 확인.

2. **공유 볼륨(Volume) 검증**:
   - 각 단계별로 `shared_volume` 폴더에 파일이 실제로 생성되고 삭제되는지 확인.

---

## 🚀 CI/CD 파이프라인 (GitHub Actions)
계획서의 `main.yml`에 따라 다음 테스트들이 자동으로 수행되도록 구성합니다.

1. **Push to Main**:
   - **Node.js**: `npm test` (Supertest)
   - **C++**: `ctest` (GoogleTest)
   - **Python**: `pytest` (Model & API Test)
2. **결과**: 모든 테스트가 통과(Green)해야만 배포 가능.

