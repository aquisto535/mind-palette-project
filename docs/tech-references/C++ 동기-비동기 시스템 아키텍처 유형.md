___
### 1. **I/O 처리 모델**

| 유형                    | 설명                   | 특징                       | 장점                   | 단점                    | 적용 사례     |
| --------------------- | -------------------- | ------------------------ | -------------------- | --------------------- | --------- |
| **Blocking I/O**      | 작업 완료까지 대기           | • 동기적 처리<br>• 간단한 구현     | • 구현 단순<br>• 디버깅 용이  | • 낮은 처리량<br>• 리소스 비효율 | 간단한 클라이언트 |
| **Non-blocking I/O**  | 즉시 반환, 폴링 필요         | • 주기적 상태 확인<br>• CPU 집약적 | • 응답성 향상<br>• 제어 가능  | • CPU 낭비<br>• 복잡한 로직  | 실시간 시스템   |
| **I/O Multiplexing**  | select/poll/epoll 사용 | • 다중 소켓 관리<br>• 이벤트 기반   | • 다중 연결 처리<br>• 효율적  | • 플랫폼 의존성<br>• 확장성 제한 | 네트워크 서버   |
| **Asynchronous I/O**  | 완료 시 콜백 실행           | • 완전 비동기<br>• 콜백 기반      | • 높은 처리량<br>• 확장성 우수 | • 복잡한 구현<br>• 디버깅 어려움 | 고성능 서버    |
| **Signal-driven I/O** | 시그널로 완료 통지           | • SIGIO 사용<br>• 유닉스 계열   | • 커널 수준 통지<br>• 효율적  | • 이식성 부족<br>• 제한된 기능  | 유닉스 서버    |
### 2. **스레딩 모델**

| 유형                        | 설명        | 특징                   | 장점                    | 단점                     | 적용 사례  |
| ------------------------- | --------- | -------------------- | --------------------- | ---------------------- | ------ |
| **Single-threaded**       | 단일 스레드 처리 | • 순차적 실행<br>• 동시성 없음 | • 간단한 구현<br>• 동기화 불필요 | • 멀티코어 미활용<br>• 블로킹 위험 | 간단한 도구 |
| **Thread-per-connection** | 연결당 스레드   | • 1:1 매핑<br>• 간단한 모델 | • 직관적<br>• 독립적 처리     | • 리소스 과다<br>• 확장성 제한   | 소규모 서버 |
| **Thread Pool**           | 고정 스레드 풀  | • 재사용 가능<br>• 큐 기반   | • 리소스 제한<br>• 효율적 관리  | • 튜닝 필요<br>• 작업 대기     | 웹 서버   |
| **Work Stealing**         | 작업 훔치기    | • 동적 부하 분산<br>• 효율적  | • 자동 밸런싱<br>• 높은 활용도  | • 복잡한 구현<br>• 오버헤드     | 병렬 처리  |
| **Actor Model**           | 메시지 기반    | • 격리된 액터<br>• 메시지 전달 | • 높은 동시성<br>• 확장성     | • 성능 오버헤드<br>• 학습 곡선   | 분산 시스템 |
### 3. **이벤트 처리 패턴**

|유형|설명|특징|장점|단점|적용 사례|
|---|---|---|---|---|---|
|**Reactor**|동기적 이벤트 분배|• 이벤트 루프<br>• 핸들러 호출|• 단순한 구조<br>• 예측 가능|• 단일 스레드 제한<br>• 블로킹 위험|Node.js, Redis|
|**Proactor**|비동기 완료 통지|• 비동기 작업<br>• 완료 핸들러|• 높은 동시성<br>• 논블로킹|• 복잡한 구현<br>• 플랫폼 의존|ASIO, IOCP|
|**Half-Sync/Half-Async**|동기/비동기 혼합|• 계층 분리<br>• 큐 연결|• 균형적 접근<br>• 유연성|• 복잡도 증가<br>• 성능 오버헤드|엔터프라이즈 앱|
|**Leader/Followers**|동적 역할 교체|• 스레드 풀<br>• 역할 전환|• 효율적 처리<br>• 낮은 지연|• 동기화 복잡<br>• 구현 난이도|
### 4. **동시성 제어 메커니즘**

| 유형             | 설명             | 특징                      | 장점                  | 단점                  | 적용 사례    |
| -------------- | -------------- | ----------------------- | ------------------- | ------------------- | -------- |
| **Mutex/Lock** | 상호 배제          | • 블로킹 동기화<br>• 임계영역 보호  | • 강력한 보장<br>• 직관적   | • 데드락 위험<br>• 성능 저하 | 공유 자원 보호 |
| **Lock-free**  | 무잠금 알고리즘       | • CAS 연산<br>• atomic 사용 | • 높은 성능<br>• 데드락 없음 | • 구현 복잡<br>• ABA 문제 | 고성능 큐    |
| **Wait-free**  | 대기 없는 알고리즘     | • 보장된 진행<br>• 최대 성능     | • 예측 가능<br>• 최고 성능  | • 매우 복잡<br>• 제한적 적용 | 실시간 시스템  |
| **STM**        | 소프트웨어 트랜잭션 메모리 | • 트랜잭션<br>• 롤백 가능       | • 조합 가능<br>• 데드락 없음 | • 오버헤드<br>• 메모리 사용  | 복잡한 동시성  |
### 5. **비동기 프로그래밍 모델**

| 유형                 | 설명        | 특징                       | 장점                  | 단점                      | 적용 사례   |
| ------------------ | --------- | ------------------------ | ------------------- | ----------------------- | ------- |
| **Callback**       | 콜백 함수     | • 완료 시 호출<br>• 이벤트 기반    | • 간단한 개념<br>• 널리 사용 | • 콜백 지옥<br>• 에러 처리 복잡   | 이벤트 처리  |
| **Promise/Future** | 미래 값 표현   | • 지연된 결과<br>• 체이닝 가능     | • 조합 가능<br>• 깔끔한 코드 | • 메모리 오버헤드<br>• 학습 필요   | 비동기 API |
| **Coroutine**      | 협력적 멀티태스킹 | • 일시 중단/재개<br>• co_await | • 동기 스타일<br>• 효율적   | • C++20 필요<br>• 컴파일러 지원 | 현대적 비동기 |
| **Reactive**       | 반응형 스트림   | • 데이터 플로우<br>• 백프레셔      | • 조합 가능<br>• 확장성    | • 복잡한 개념<br>• 디버깅 어려움   | 스트리밍 처리 |
### 6. **아키텍처 패턴**

| 유형                  | 설명     | 특징                    | 장점                   | 단점                    | 적용 사례   |
| ------------------- | ------ | --------------------- | -------------------- | --------------------- | ------- |
| **Pipeline**        | 단계별 처리 | • 순차적 단계<br>• 버퍼 연결   | • 명확한 구조<br>• 병렬화 가능 | • 지연 시간<br>• 버퍼 관리    | 데이터 처리  |
| **Event-driven**    | 이벤트 중심 | • 느슨한 결합<br>• 비동기 통신  | • 확장성<br>• 유연성       | • 복잡한 흐름<br>• 디버깅 어려움 | GUI, 서버 |
| **Message Passing** | 메시지 교환 | • 프로세스 간 통신<br>• 큐 기반 | • 격리성<br>• 확장 가능     | • 직렬화 비용<br>• 지연 시간   | 분산 시스템  |
| **Shared Memory**   | 메모리 공유 | • 직접 접근<br>• 빠른 통신    | • 높은 성능<br>• 낮은 지연   | • 동기화 복잡<br>• 경합 상태   | 고성능 컴퓨팅 |