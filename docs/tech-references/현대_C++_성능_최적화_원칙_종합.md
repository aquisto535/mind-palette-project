# í˜„ëŒ€ C++ ì„±ëŠ¥ ìµœì í™” ì›ì¹™ ì¢…í•©

## ğŸ“š ë¬¸ì„œ ê°œìš”
ì´ ë¬¸ì„œëŠ” í˜„ëŒ€ C++ (C++11 ì´í›„)ì˜ ì„±ëŠ¥ ìµœì í™” í•µì‹¬ ì›ì¹™ë“¤ì„ ì¢…í•©ì ìœ¼ë¡œ ì •ë¦¬í•©ë‹ˆë‹¤.

---

## ğŸ¯ í•µì‹¬ ì›ì¹™ ìš”ì•½

| ìˆœìœ„  | ì›ì¹™                        | ì„¤ëª…                 | í•µì‹¬ í‚¤ì›Œë“œ             |
| --- | ------------------------- | ------------------ | ------------------ |
| 1   | **Zero-Cost Abstraction** | ì¶”ìƒí™”ë¥¼ ì‚¬ìš©í•´ë„ ì„±ëŠ¥ ì €í•˜ ì—†ìŒ | í…œí”Œë¦¿, ì¸ë¼ì¸, ì»´íŒŒì¼ íƒ€ì„   |
| 2   | **ë¶ˆí•„ìš”í•œ ë³µì‚¬ ì œê±°**            | ë³µì‚¬ ëŒ€ì‹  ì´ë™ ë˜ëŠ” ì°¸ì¡° ì‚¬ìš©  | Move, ì°¸ì¡°, emplace  |
| 3   | **RAII**                  | ìì› ê´€ë¦¬ ìë™í™” + ì„±ëŠ¥ ë³´ì¥  | ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°, ìë™ í•´ì œ     |
| 4   | **ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚°**             | ëŸ°íƒ€ì„ ëŒ€ì‹  ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚°  | constexpr, ë©”íƒ€í”„ë¡œê·¸ë˜ë° |
| 5   | **ë©”ëª¨ë¦¬ ì§€ì—­ì„±**               | ìºì‹œ ì¹œí™”ì  ë°ì´í„° êµ¬ì¡° ì‚¬ìš©   | ì—°ì† ë©”ëª¨ë¦¬, vector ìš°ì„   |

### ğŸ’¡ í™©ê¸ˆë¥ 
```
"ìƒì„±ì€ ìµœì†Œí•œìœ¼ë¡œ, ì´ë™ì€ ê°€ëŠ¥í•˜ë©´, ë³µì‚¬ëŠ” ì ˆëŒ€ í”¼í•˜ë¼"
```

---

## ğŸ“‹ 1. ê°ì²´ ìƒì„± ë° ë³µì‚¬ ìµœì í™”

| ê¸°ë²• | ë‚˜ìœ ì˜ˆ âŒ | ì¢‹ì€ ì˜ˆ âœ… | ì„±ëŠ¥ í–¥ìƒ | ì ìš© ì‹œì  |
|------|-----------|-----------|----------|-----------|
| **emplace ì‚¬ìš©** | `vec.push_back(T(args))` | `vec.emplace_back(args)` | ~30% | í•­ìƒ |
| **ì´ë™ ì˜ë¯¸ë¡ ** | `vec.push_back(obj)` | `vec.push_back(std::move(obj))` | ~50% | ì„ì‹œ ê°ì²´ |
| **ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸** | `vec.push_back(1); vec.push_back(2);` | `vector<int> v = {1, 2};` | ~40% | ì´ˆê¸°í™” |
| **reserve ì‚¬ìš©** | ì¬í• ë‹¹ ë°œìƒ | `vec.reserve(1000);` | ~60% | í¬ê¸° ì˜ˆì¸¡ ê°€ëŠ¥ |
| **RVO í™œìš©** | `return std::move(local);` | `return local;` | ì»´íŒŒì¼ëŸ¬ ìµœì í™” | í•¨ìˆ˜ ë°˜í™˜ |
| **Perfect Forwarding** | `func(T(args))` | `func(std::forward<T>(args))` | ~25% | í…œí”Œë¦¿ í•¨ìˆ˜ |

### ì½”ë“œ ì˜ˆì œ

```cpp
// âŒ ë¹„íš¨ìœ¨ì : ì„ì‹œ ê°ì²´ + ë³µì‚¬/ì´ë™
std::vector<std::string> names;
names.push_back(std::string("Alice"));  
// ë¹„ìš©: ìƒì„±(1) + ì´ë™(1) + ì†Œë©¸(1) = 3ë‹¨ê³„

// âœ… íš¨ìœ¨ì : ì§ì ‘ ìƒì„±
names.emplace_back("Alice");
// ë¹„ìš©: ìƒì„±(1) = 1ë‹¨ê³„
// ì„±ëŠ¥ í–¥ìƒ: ì•½ 37%
```

---

## ğŸ“‹ 2. ë©”ëª¨ë¦¬ ê´€ë¦¬ ìµœì í™”

| ê¸°ë²• | ë‚˜ìœ ì˜ˆ âŒ | ì¢‹ì€ ì˜ˆ âœ… | íš¨ê³¼ | ì‚¬ìš© ì´ìœ  |
|------|-----------|-----------|------|-----------|
| **ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°** | `new` / `delete` | `std::unique_ptr`, `std::shared_ptr` | ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ | RAII |
| **Stack ìš°ì„ ** | í™ í• ë‹¹ ë‚¨ìš© | ê°€ëŠ¥í•˜ë©´ ìŠ¤íƒ ì‚¬ìš© | ë¹ ë¥¸ í• ë‹¹/í•´ì œ | ì§€ì—­ì„± |
| **ì»¨í…Œì´ë„ˆ ì¬ì‚¬ìš©** | ë§¤ë²ˆ ìƒˆë¡œ ìƒì„± | `vec.clear(); vec.reserve();` | ì¬í• ë‹¹ ë°©ì§€ | ë°˜ë³µ ì‚¬ìš© |
| **Custom Allocator** | ê¸°ë³¸ allocator | í’€ í• ë‹¹ì ì‚¬ìš© | í• ë‹¹ ì†ë„ í–¥ìƒ | ë¹ˆë²ˆí•œ í• ë‹¹ |
| **ì‘ì€ ê°ì²´ ìµœì í™”** | í•­ìƒ í™ í• ë‹¹ | SSO, SBO í™œìš© | í™ í• ë‹¹ ì œê±° | ì‘ì€ ë°ì´í„° |

### ì½”ë“œ ì˜ˆì œ

```cpp
// âŒ ìˆ˜ë™ ë©”ëª¨ë¦¬ ê´€ë¦¬
Widget* ptr = new Widget();
// ... ì‚¬ìš© ...
delete ptr;  // ì˜ˆì™¸ ë°œìƒ ì‹œ ëˆ„ìˆ˜!

// âœ… ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° (RAII)
auto ptr = std::make_unique<Widget>();
// ... ì‚¬ìš© ...
// ìë™ í•´ì œ, ì˜ˆì™¸ ì•ˆì „
```

---

## ğŸ“‹ 3. í•¨ìˆ˜ ë° ë§¤ê°œë³€ìˆ˜ ì „ë‹¬ ìµœì í™”

| ë§¤ê°œë³€ìˆ˜ íƒ€ì… | ë¹„ìš© | ì‚¬ìš© ì‹œì  | ì˜ˆì‹œ | ì„±ëŠ¥ |
|--------------|------|-----------|------|------|
| **ê°’ ì „ë‹¬** `T` | ë†’ìŒ (ë³µì‚¬) | ì‘ì€ íƒ€ì… (int, char) | `void f(int x)` | â­ |
| **const ì°¸ì¡°** `const T&` | ë‚®ìŒ (ë³µì‚¬ ì—†ìŒ) | ì½ê¸° ì „ìš©, í° ê°ì²´ | `void f(const string& s)` | â­â­â­â­â­ |
| **ì°¸ì¡°** `T&` | ë‚®ìŒ | ìˆ˜ì • í•„ìš” | `void f(vector<int>& v)` | â­â­â­â­â­ |
| **ì´ë™ ì°¸ì¡°** `T&&` | ë‚®ìŒ (ì´ë™) | ì„ì‹œ ê°ì²´, ì†Œìœ ê¶Œ ì´ì „ | `void f(string&& s)` | â­â­â­â­â­ |
| **Universal ì°¸ì¡°** `T&&` | ìµœì  | í…œí”Œë¦¿, ì™„ë²½ ì „ë‹¬ | `template<typename T> void f(T&& t)` | â­â­â­â­â­ |
| **í¬ì¸í„°** `T*` | ë‚®ìŒ | nullable, C í˜¸í™˜ | `void f(int* p)` | â­â­â­ |

### ì½”ë“œ ì˜ˆì œ

```cpp
// âŒ ë¹„íš¨ìœ¨ì : ê°’ìœ¼ë¡œ ì „ë‹¬ (í° ê°ì²´ ë³µì‚¬)
void process(std::vector<int> data) {  // ì „ì²´ ë²¡í„° ë³µì‚¬!
    // ...
}

// âœ… íš¨ìœ¨ì : const ì°¸ì¡°ë¡œ ì „ë‹¬
void process(const std::vector<int>& data) {  // ë³µì‚¬ ì—†ìŒ
    // ...
}

// âœ… ìˆ˜ì • í•„ìš” ì‹œ: ì°¸ì¡°ë¡œ ì „ë‹¬
void modify(std::vector<int>& data) {
    data.push_back(42);
}

// âœ… ì†Œìœ ê¶Œ ì´ì „: ì´ë™ ì°¸ì¡°
void take_ownership(std::vector<int>&& data) {
    stored_data = std::move(data);
}
```

---

## ğŸ“‹ 4. ì»¨í…Œì´ë„ˆ ì„ íƒ ìµœì í™”

| ì‘ì—… | ìµœì  ì»¨í…Œì´ë„ˆ | ì‹œê°„ ë³µì¡ë„ | ì´ìœ  | ëŒ€ì•ˆ |
|------|---------------|-------------|------|------|
| **ìˆœì°¨ ì ‘ê·¼** | `std::vector` | O(1) | ìºì‹œ ì¹œí™”ì  | `std::deque` |
| **ë¹ˆë²ˆí•œ ì‚½ì…/ì‚­ì œ (ì¤‘ê°„)** | `std::list` | O(1) | í¬ì¸í„° ì—°ê²°ë§Œ | `std::deque` |
| **ë¹ˆë²ˆí•œ ì‚½ì…/ì‚­ì œ (ì–‘ë)** | `std::deque` | O(1) | ë¸”ë¡ ë‹¨ìœ„ ê´€ë¦¬ | `std::list` |
| **ë¹ ë¥¸ ê²€ìƒ‰** | `std::unordered_set/map` | O(1) avg | í•´ì‹œ í…Œì´ë¸” | `std::set/map` |
| **ì •ë ¬ëœ ë°ì´í„°** | `std::set/map` | O(log n) | Red-Black Tree | `std::vector` + sort |
| **ê³ ì • í¬ê¸°** | `std::array` | O(1) | ìŠ¤íƒ í• ë‹¹ | `std::vector` |
| **LIFO** | `std::stack` | O(1) | ì œí•œëœ ì¸í„°í˜ì´ìŠ¤ | `std::vector` |
| **FIFO** | `std::queue` | O(1) | ì œí•œëœ ì¸í„°í˜ì´ìŠ¤ | `std::deque` |

### ì„ íƒ ê°€ì´ë“œ

```cpp
// ê¸°ë³¸ì ìœ¼ë¡œ std::vector ì‚¬ìš©
std::vector<int> data;  // ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ìµœì 

// ë¹ ë¥¸ ê²€ìƒ‰ì´ í•„ìš”í•œ ê²½ìš°
std::unordered_map<string, int> cache;  // O(1) í‰ê· 

// ì •ë ¬ì´ í•„ìš”í•œ ê²½ìš°
std::set<int> sorted_data;  // ìë™ ì •ë ¬ ìœ ì§€

// ì–‘ ë ì‚½ì…/ì‚­ì œê°€ ë§ì€ ê²½ìš°
std::deque<Task> task_queue;
```

---

## ğŸ“‹ 5. ì•Œê³ ë¦¬ì¦˜ ìµœì í™”

| ê¸°ë²• | ë‚˜ìœ ì˜ˆ âŒ | ì¢‹ì€ ì˜ˆ âœ… | ì‹œê°„ ë³µì¡ë„ ê°œì„  |
|------|-----------|-----------|------------------|
| **STL ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©** | ìˆ˜ë™ ë°˜ë³µë¬¸ | `std::find`, `std::sort` | ìµœì í™”ë¨ |
| **ë³‘ë ¬ ì•Œê³ ë¦¬ì¦˜** | `std::sort` | `std::execution::par, std::sort` | ~4ë°° (ë©€í‹°ì½”ì–´) |
| **ë²”ìœ„ ê¸°ë°˜ for** | ì¸ë±ìŠ¤ ì ‘ê·¼ | `for (const auto& x : vec)` | ì»´íŒŒì¼ëŸ¬ ìµœì í™” |
| **iterator í™œìš©** | `vec[i]` ë°˜ë³µ | `auto it = vec.begin()` | ì¼ë°˜ì„± + ìµœì í™” |
| **constexpr í•¨ìˆ˜** | ëŸ°íƒ€ì„ ê³„ì‚° | `constexpr int factorial(int n)` | ì»´íŒŒì¼ íƒ€ì„ |

### ì½”ë“œ ì˜ˆì œ

```cpp
// âŒ ìˆ˜ë™ ì •ë ¬ (ëŠë¦¼)
for (int i = 0; i < n; ++i) {
    for (int j = i+1; j < n; ++j) {
        if (arr[i] > arr[j]) {
            std::swap(arr[i], arr[j]);
        }
    }
}

// âœ… STL ì•Œê³ ë¦¬ì¦˜ (ë¹ ë¦„)
std::sort(vec.begin(), vec.end());

// âœ…âœ… ë³‘ë ¬ ì•Œê³ ë¦¬ì¦˜ (ë§¤ìš° ë¹ ë¦„, C++17)
std::sort(std::execution::par, vec.begin(), vec.end());
```

---

## ğŸ“‹ 6. ì»´íŒŒì¼ íƒ€ì„ ìµœì í™”

| ê¸°ë²• | ì„¤ëª… | ì˜ˆì‹œ | íš¨ê³¼ |
|------|------|------|------|
| **constexpr** | ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ | `constexpr int SIZE = 100;` | ëŸ°íƒ€ì„ ë¹„ìš© 0 |
| **constexpr í•¨ìˆ˜** | ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚° | `constexpr int square(int x) { return x*x; }` | ëŸ°íƒ€ì„ ë¹„ìš© 0 |
| **í…œí”Œë¦¿ ë©”íƒ€í”„ë¡œê·¸ë˜ë°** | ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚° | `template<int N> struct Factorial` | ëŸ°íƒ€ì„ ë¹„ìš© 0 |
| **if constexpr** | ì»´íŒŒì¼ íƒ€ì„ ë¶„ê¸° | `if constexpr (sizeof(T) > 8)` | ë¶ˆí•„ìš”í•œ ì½”ë“œ ì œê±° |
| **consteval (C++20)** | ê°•ì œ ì»´íŒŒì¼ íƒ€ì„ | `consteval int compile_time_only()` | ëŸ°íƒ€ì„ í˜¸ì¶œ ë¶ˆê°€ |

### ì½”ë“œ ì˜ˆì œ

```cpp
// âŒ ëŸ°íƒ€ì„ ê³„ì‚°
int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n-1);
}
int result = factorial(5);  // ì‹¤í–‰ ì¤‘ ê³„ì‚°

// âœ… ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚°
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n-1);
}
constexpr int result = factorial(5);  // ì»´íŒŒì¼ ì‹œ ê³„ì‚°ë¨ (120ìœ¼ë¡œ ëŒ€ì²´)
```

---

## ğŸ“‹ 7. ë©€í‹°ìŠ¤ë ˆë”© ìµœì í™”

| ê¸°ë²• | ë‚˜ìœ ì˜ˆ âŒ | ì¢‹ì€ ì˜ˆ âœ… | ì„±ëŠ¥ í–¥ìƒ |
|------|-----------|-----------|----------|
| **thread ìƒì„±** | `thread t(...); vec.push_back(move(t));` | `vec.emplace_back(...)` | ~20% |
| **mutex ë²”ìœ„** | í•¨ìˆ˜ ì „ì²´ ì ê¸ˆ | ìµœì†Œ ë²”ìœ„ë§Œ ì ê¸ˆ | ~50% |
| **atomic ì‚¬ìš©** | `mutex + counter++` | `atomic<int> counter++` | ~80% |
| **lock-free ìë£Œêµ¬ì¡°** | mutex ê¸°ë°˜ í | `boost::lockfree::queue` | ~3ë°° |
| **thread_local** | ì „ì—­ ë³€ìˆ˜ + mutex | `thread_local int cache` | mutex ë¶ˆí•„ìš” |

### ì½”ë“œ ì˜ˆì œ

```cpp
// âŒ ë„“ì€ ì ê¸ˆ ë²”ìœ„
void process() {
    std::lock_guard<std::mutex> lock(mtx);  // ì „ì²´ í•¨ìˆ˜ ì ê¸ˆ
    expensive_computation();  // ì ê¸ˆ ë¶ˆí•„ìš”í•œ ë¶€ë¶„
    shared_data++;            // ì‹¤ì œ ì ê¸ˆ í•„ìš”í•œ ë¶€ë¶„
    another_computation();    // ì ê¸ˆ ë¶ˆí•„ìš”í•œ ë¶€ë¶„
}

// âœ… ìµœì†Œ ì ê¸ˆ ë²”ìœ„
void process() {
    expensive_computation();  // ì ê¸ˆ ì—†ì´ ì‹¤í–‰
    
    {
        std::lock_guard<std::mutex> lock(mtx);  // ìµœì†Œ ë²”ìœ„ë§Œ ì ê¸ˆ
        shared_data++;
    }
    
    another_computation();  // ì ê¸ˆ ì—†ì´ ì‹¤í–‰
}

// âœ…âœ… atomic ì‚¬ìš© (ë” ë¹ ë¦„)
std::atomic<int> shared_data{0};
void process() {
    expensive_computation();
    shared_data++;  // mutex ë¶ˆí•„ìš”
    another_computation();
}
```

---

## ğŸ“‹ 8. ìºì‹œ ì¹œí™”ì  í”„ë¡œê·¸ë˜ë°

| ì›ì¹™ | ë‚˜ìœ ì˜ˆ âŒ | ì¢‹ì€ ì˜ˆ âœ… | ì´ìœ  |
|------|-----------|-----------|------|
| **ì—°ì† ë©”ëª¨ë¦¬** | `std::list` | `std::vector` | ìºì‹œ íˆíŠ¸ìœ¨ í–¥ìƒ |
| **ë°ì´í„° ì§€ì—­ì„±** | ì‚°ì¬ëœ ì ‘ê·¼ | ìˆœì°¨ ì ‘ê·¼ | í”„ë¦¬í˜ì¹˜ íš¨ê³¼ |
| **êµ¬ì¡°ì²´ ì •ë ¬** | `struct { char, int, char }` | `struct { int, char, char }` | íŒ¨ë”© ìµœì†Œí™” |
| **AoS vs SoA** | Array of Structs | Struct of Arrays | SIMD ìµœì í™” |
| **false sharing ë°©ì§€** | ì¸ì ‘ ë³€ìˆ˜ ê³µìœ  | `alignas(64)` ì‚¬ìš© | ìºì‹œ ë¼ì¸ ë¶„ë¦¬ |

### ì½”ë“œ ì˜ˆì œ

```cpp
// âŒ ìºì‹œ ë¹„ì¹œí™”ì : ì‚°ì¬ëœ ë©”ëª¨ë¦¬ (list)
std::list<int> data;
for (int i = 0; i < 1000000; ++i) {
    data.push_back(i);
}
// ê° ë…¸ë“œê°€ ë©”ëª¨ë¦¬ ê³³ê³³ì— í©ì–´ì§ â†’ ìºì‹œ ë¯¸ìŠ¤ ë¹ˆë²ˆ

// âœ… ìºì‹œ ì¹œí™”ì : ì—°ì† ë©”ëª¨ë¦¬ (vector)
std::vector<int> data;
data.reserve(1000000);
for (int i = 0; i < 1000000; ++i) {
    data.push_back(i);
}
// ì—°ì†ëœ ë©”ëª¨ë¦¬ â†’ ìºì‹œ íˆíŠ¸ìœ¨ ë†’ìŒ â†’ ì•½ 10ë°° ë¹ ë¦„

// âŒ êµ¬ì¡°ì²´ ì •ë ¬ (íŒ¨ë”© ë°œìƒ)
struct Bad {
    char a;   // 1 byte
    int b;    // 4 bytes (ì•ì— 3 byte íŒ¨ë”©)
    char c;   // 1 byte (ë’¤ì— 3 byte íŒ¨ë”©)
};  // ì´ 12 bytes

// âœ… êµ¬ì¡°ì²´ ì •ë ¬ (íŒ¨ë”© ìµœì†Œí™”)
struct Good {
    int b;    // 4 bytes
    char a;   // 1 byte
    char c;   // 1 byte (ë’¤ì— 2 byte íŒ¨ë”©)
};  // ì´ 8 bytes (33% ì ˆì•½)
```

---

## ğŸ† ìš°ì„ ìˆœìœ„ë³„ ì ìš© ê°€ì´ë“œ

### ğŸ¥‡ ìš°ì„ ìˆœìœ„ 1: ì¦‰ì‹œ ì ìš© (ê³ íš¨ê³¼, ì‰¬ì›€)

```cpp
// 1. emplace ê³„ì—´ ì‚¬ìš©
vec.emplace_back(args);          // push_back ëŒ€ì‹ 

// 2. const ì°¸ì¡° ì „ë‹¬
void func(const string& s);      // ê°’ ì „ë‹¬ ëŒ€ì‹ 

// 3. reserve() ì‚¬ìš©
vec.reserve(1000);               // ì¬í• ë‹¹ ë°©ì§€

// 4. ë²”ìœ„ ê¸°ë°˜ for + ì°¸ì¡°
for (const auto& item : vec)     // ì¸ë±ìŠ¤ ì ‘ê·¼ ëŒ€ì‹ 

// 5. ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°
auto ptr = make_unique<T>();     // new/delete ëŒ€ì‹ 
```

### ğŸ¥ˆ ìš°ì„ ìˆœìœ„ 2: ìƒí™©ë³„ ì ìš© (ì¤‘íš¨ê³¼, ë³´í†µ)

```cpp
// 1. ì´ë™ ì˜ë¯¸ë¡ 
vec.push_back(std::move(obj));

// 2. Perfect Forwarding
template<typename T>
void add(T&& value) {
    vec.emplace_back(std::forward<T>(value));
}

// 3. STL ì•Œê³ ë¦¬ì¦˜
std::sort(vec.begin(), vec.end());

// 4. ì ì ˆí•œ ì»¨í…Œì´ë„ˆ ì„ íƒ
std::unordered_map (vs std::map)
```

### ğŸ¥‰ ìš°ì„ ìˆœìœ„ 3: ê³ ê¸‰ ìµœì í™” (ì „ë¬¸ê°€)

```cpp
// 1. constexpr
constexpr int compute() { return ...; }

// 2. ë³‘ë ¬ ì•Œê³ ë¦¬ì¦˜
std::sort(std::execution::par, vec.begin(), vec.end());

// 3. Custom Allocator
std::vector<int, MyAllocator<int>> vec;

// 4. ìºì‹œ ìµœì í™”
alignas(64) int data[N];
```

---

## ğŸ“ˆ ì„±ëŠ¥ ì˜í–¥ë„ ë¹„êµ

| ìµœì í™” ê¸°ë²• | ì„±ëŠ¥ í–¥ìƒ | êµ¬í˜„ ë‚œì´ë„ | ì ìš© ë¹ˆë„ | ìš°ì„ ìˆœìœ„ |
|------------|----------|------------|----------|---------|
| emplace vs push_back | 30-50% | â­ | ë†’ìŒ | ğŸ¥‡ |
| const ì°¸ì¡° ì „ë‹¬ | 50-90% | â­ | ë†’ìŒ | ğŸ¥‡ |
| reserve() | 60-80% | â­ | ì¤‘ê°„ | ğŸ¥‡ |
| ì´ë™ ì˜ë¯¸ë¡  | 50-70% | â­â­ | ì¤‘ê°„ | ğŸ¥ˆ |
| ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° | ì•ˆì •ì„±++ | â­â­ | ë†’ìŒ | ğŸ¥‡ |
| Perfect Forwarding | 20-40% | â­â­â­ | ë‚®ìŒ | ğŸ¥ˆ |
| ë³‘ë ¬ ì•Œê³ ë¦¬ì¦˜ | 200-400% | â­â­â­ | ë‚®ìŒ | ğŸ¥‰ |
| constexpr | 100% | â­â­â­ | ë‚®ìŒ | ğŸ¥‰ |
| Lock-free ìë£Œêµ¬ì¡° | 300-500% | â­â­â­â­â­ | ë§¤ìš° ë‚®ìŒ | ğŸ¥‰ |

---

## ğŸ¯ ìƒí™©ë³„ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸

### âœ… ì¼ë°˜ ì½”ë“œ
- [ ] emplace ê³„ì—´ ì‚¬ìš©
- [ ] const ì°¸ì¡°ë¡œ ì „ë‹¬
- [ ] reserve() í˜¸ì¶œ
- [ ] ë²”ìœ„ ê¸°ë°˜ forë¬¸ + ì°¸ì¡°
- [ ] ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì‚¬ìš©
- [ ] ì ì ˆí•œ ì»¨í…Œì´ë„ˆ ì„ íƒ

### âœ… ì„±ëŠ¥ í¬ë¦¬í‹°ì»¬ ì½”ë“œ
- [ ] ì•Œê³ ë¦¬ì¦˜ ë³µì¡ë„ ê²€í†  (O(nÂ²) â†’ O(n log n))
- [ ] ì ì ˆí•œ ì»¨í…Œì´ë„ˆ ì„ íƒ (vector ìš°ì„ )
- [ ] ë©”ëª¨ë¦¬ ì§€ì—­ì„± ê³ ë ¤
- [ ] í”„ë¡œíŒŒì¼ë§ ìˆ˜í–‰
- [ ] ë³‘ë ¬í™” ê²€í† 
- [ ] constexpr í™œìš©

### âœ… ë©€í‹°ìŠ¤ë ˆë“œ ì½”ë“œ
- [ ] ì ê¸ˆ ë²”ìœ„ ìµœì†Œí™”
- [ ] atomic í™œìš©
- [ ] thread_local ê³ ë ¤
- [ ] lock-free ìë£Œêµ¬ì¡° ê²€í† 
- [ ] false sharing ë°©ì§€

### âœ… ë©”ëª¨ë¦¬ ì§‘ì•½ì  ì½”ë“œ
- [ ] ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ë¡œ ìë™ ê´€ë¦¬
- [ ] ì»¨í…Œì´ë„ˆ ì¬ì‚¬ìš© (clear + reserve)
- [ ] Custom Allocator ê³ ë ¤
- [ ] ì‘ì€ ê°ì²´ ìµœì í™” (SSO) í™œìš©
- [ ] ë©”ëª¨ë¦¬ í’€ ì‚¬ìš© ê²€í† 

---

## ğŸ’¡ ì‹¤ì „ ì„±ëŠ¥ ì¸¡ì •

### ë²¤ì¹˜ë§ˆí‚¹ í…œí”Œë¦¿

```cpp
#include <chrono>
#include <iostream>

template<typename Func>
void benchmark(const std::string& name, Func func) {
    auto start = std::chrono::high_resolution_clock::now();
    
    func();  // ì¸¡ì •í•  ì½”ë“œ ì‹¤í–‰
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    std::cout << name << ": " << duration.count() << "Î¼s" << std::endl;
}

// ì‚¬ìš© ì˜ˆ
int main() {
    const int N = 1000000;
    
    benchmark("push_back", [&]() {
        std::vector<std::string> vec;
        for (int i = 0; i < N; ++i) {
            vec.push_back(std::string("test"));
        }
    });
    
    benchmark("emplace_back", [&]() {
        std::vector<std::string> vec;
        for (int i = 0; i < N; ++i) {
            vec.emplace_back("test");
        }
    });
    
    return 0;
}
```

---

## ğŸ“š ì°¸ê³  ìë£Œ

### í•µì‹¬ ì›ì¹™
1. **Zero-Cost Abstraction**: ì¶”ìƒí™” ë¹„ìš© 0
2. **RAII**: ìì› ìë™ ê´€ë¦¬
3. **Move Semantics**: ë³µì‚¬ ëŒ€ì‹  ì´ë™
4. **Perfect Forwarding**: ìµœì  ì „ë‹¬
5. **Compile-Time Computation**: ëŸ°íƒ€ì„ ë¹„ìš© ì œê±°

### ì¶”ì²œ ë„êµ¬
- **í”„ë¡œíŒŒì¼ëŸ¬**: Valgrind, perf, VTune
- **ë©”ëª¨ë¦¬ ë¶„ì„**: Valgrind (memcheck), AddressSanitizer
- **ì •ì  ë¶„ì„**: Clang-Tidy, Cppcheck
- **ë²¤ì¹˜ë§ˆí¬**: Google Benchmark, Catch2

### ë” í•™ìŠµí•˜ê¸°
- Effective Modern C++ (Scott Meyers)
- C++ Concurrency in Action (Anthony Williams)
- Optimized C++ (Kurt Guntheroth)
- CppCon ë°œí‘œ ìë£Œë“¤

---

## ğŸ“– 9. í•µì‹¬ ì›ì¹™ ìƒì„¸ ì„¤ëª…

### ğŸ¯ 9.1 Zero-Cost Abstraction (ë¬´ë¹„ìš© ì¶”ìƒí™”)

#### í•µì‹¬ ê°œë…
**"ì¶”ìƒí™”ë¥¼ ì‚¬ìš©í•´ë„ ì„±ëŠ¥ ì €í•˜ê°€ ì—†ë‹¤"**ëŠ” C++ì˜ ì² í•™ì…ë‹ˆë‹¤. ì¦‰, ê³ ìˆ˜ì¤€ ì½”ë“œë¥¼ ì‘ì„±í•´ë„ ì €ìˆ˜ì¤€ ìˆ˜ë™ ì½”ë“œë§Œí¼ ë¹ ë¦…ë‹ˆë‹¤.

#### ë™ì‘ ì›ë¦¬

```
ê°œë°œì ì½”ë“œ (ê³ ìˆ˜ì¤€ ì¶”ìƒí™”)
        â†“
   ì»´íŒŒì¼ëŸ¬ ìµœì í™”
        â†“
ê¸°ê³„ì–´ ì½”ë“œ (ì €ìˆ˜ì¤€ê³¼ ë™ì¼)
```

#### ì‹¤ì „ ì˜ˆì‹œ 1: í…œí”Œë¦¿

```cpp
// âŒ C ìŠ¤íƒ€ì¼ (ì €ìˆ˜ì¤€, íƒ€ì… ì•ˆì „ì„± ì—†ìŒ)
void sort_int_array(int* arr, size_t n) {
    // ìˆ˜ë™ ì •ë ¬ êµ¬í˜„...
}

// âœ… C++ í…œí”Œë¦¿ (ê³ ìˆ˜ì¤€, íƒ€ì… ì•ˆì „)
std::vector<int> vec = {3, 1, 4, 1, 5};
std::sort(vec.begin(), vec.end());

// ì»´íŒŒì¼ëŸ¬ê°€ ìƒì„±í•˜ëŠ” ê¸°ê³„ì–´ ì½”ë“œëŠ” ë™ì¼í•˜ê±°ë‚˜ ë” ë¹ ë¦„!
```

**ì„±ëŠ¥ ë¹„êµ:**
```
C ìˆ˜ë™ êµ¬í˜„:    100ms
std::sort:      100ms (ë™ì¼!) + íƒ€ì… ì•ˆì „ + ì¬ì‚¬ìš©ì„±
```

#### ì‹¤ì „ ì˜ˆì‹œ 2: ì¸ë¼ì¸ í•¨ìˆ˜

```cpp
// âŒ ë§¤í¬ë¡œ (ìœ„í—˜, ë””ë²„ê¹… ì–´ë ¤ì›€)
#define MAX(a, b) ((a) > (b) ? (a) : (b))
int result = MAX(x++, y++);  // ğŸ’¥ ë¶€ì‘ìš© ë°œìƒ!

// âœ… ì¸ë¼ì¸ í•¨ìˆ˜ (ì•ˆì „, íƒ€ì… ì²´í¬)
inline int max(int a, int b) {
    return (a > b) ? a : b;
}
int result = max(x, y);

// ì»´íŒŒì¼ í›„: í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì—†ìŒ (ë§¤í¬ë¡œì™€ ë™ì¼í•œ ê¸°ê³„ì–´)
```

**ì»´íŒŒì¼ ê²°ê³¼:**
```assembly
; ë§¤í¬ë¡œì™€ ì¸ë¼ì¸ í•¨ìˆ˜ ëª¨ë‘ ë™ì¼í•œ ì–´ì…ˆë¸”ë¦¬ ìƒì„±
cmp  eax, ebx
cmovg eax, ebx
```

#### ì‹¤ì „ ì˜ˆì‹œ 3: ë²”ìœ„ ê¸°ë°˜ for

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

// âŒ ì „í†µì  ë°©ì‹
for (size_t i = 0; i < vec.size(); ++i) {
    process(vec[i]);
}

// âœ… ë²”ìœ„ ê¸°ë°˜ for (ì½ê¸° ì‰¬ì›€)
for (const auto& item : vec) {
    process(item);
}

// ì»´íŒŒì¼ëŸ¬ê°€ ìƒì„±í•˜ëŠ” ì½”ë“œëŠ” ë™ì¼!
```

#### í•µì‹¬ ê¸°ë²•
- **í…œí”Œë¦¿**: ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì…ë³„ íŠ¹í™” ì½”ë“œ ìƒì„±
- **ì¸ë¼ì¸**: í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì œê±°
- **constexpr**: ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚°

---

### ğŸ¯ 9.2 ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚° (ìƒì„¸)

#### í•µì‹¬ ê°œë…
**"ì‹¤í–‰ ì‹œê°„(ëŸ°íƒ€ì„) ëŒ€ì‹  ì»´íŒŒì¼ ì‹œê°„ì— ê³„ì‚°í•˜ì—¬ ëŸ°íƒ€ì„ ë¹„ìš©ì„ 0ìœ¼ë¡œ ë§Œë“ ë‹¤"**

#### ëŸ°íƒ€ì„ vs ì»´íŒŒì¼ íƒ€ì„ ë¹„êµ

```
[ëŸ°íƒ€ì„ ê³„ì‚°]
í”„ë¡œê·¸ë¨ ì‹¤í–‰ â†’ ê³„ì‚° ìˆ˜í–‰ â†’ ê²°ê³¼ ì–»ìŒ
                 â†‘
              (ë§¤ë²ˆ ë¹„ìš© ë°œìƒ)

[ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚°]
ì»´íŒŒì¼ â†’ ë¯¸ë¦¬ ê³„ì‚° â†’ ìƒìˆ˜ë¡œ ì¹˜í™˜
ì‹¤í–‰ â†’ ìƒìˆ˜ ì‚¬ìš© (ë¹„ìš© 0)
```

#### ì‹¤ì „ ì˜ˆì‹œ 1: constexpr ê¸°ë³¸

```cpp
// âŒ ëŸ°íƒ€ì„ ê³„ì‚° (ëŠë¦¼)
int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n-1);
}

void process() {
    int result = factorial(5);  // ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ê³„ì‚°
    // 5 * 4 * 3 * 2 * 1 = 120
}

// âœ… ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚° (ë¹ ë¦„)
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n-1);
}

void process() {
    constexpr int result = factorial(5);  // ì»´íŒŒì¼ ì‹œ ê³„ì‚°
    // ì»´íŒŒì¼ëŸ¬ê°€ "int result = 120;"ìœ¼ë¡œ ì¹˜í™˜
}
```

**ì„±ëŠ¥ ì¸¡ì •:**
```cpp
// ëŸ°íƒ€ì„ ë²„ì „
for (int i = 0; i < 1000000; ++i) {
    int x = factorial(10);  // 1,000,000ë²ˆ ê³„ì‚°
}
// ì‹œê°„: ì•½ 150ms

// ì»´íŒŒì¼ íƒ€ì„ ë²„ì „
constexpr int RESULT = factorial(10);
for (int i = 0; i < 1000000; ++i) {
    int x = RESULT;  // ìƒìˆ˜ ëŒ€ì…ë§Œ
}
// ì‹œê°„: ì•½ 1ms (150ë°° ë¹ ë¦„!)
```

#### ì‹¤ì „ ì˜ˆì‹œ 2: if constexpr (C++17)

```cpp
template<typename T>
void process(T value) {
    // âŒ ëŸ°íƒ€ì„ ë¶„ê¸° (ëŠë¦¼)
    if (sizeof(T) > 8) {
        // í° íƒ€ì… ì²˜ë¦¬
        process_large(value);
    } else {
        // ì‘ì€ íƒ€ì… ì²˜ë¦¬
        process_small(value);
    }
    
    // âœ… ì»´íŒŒì¼ íƒ€ì„ ë¶„ê¸° (ë¹ ë¦„)
    if constexpr (sizeof(T) > 8) {
        process_large(value);  // í° íƒ€ì…ì´ë©´ ì´ ì½”ë“œë§Œ ìƒì„±
    } else {
        process_small(value);  // ì‘ì€ íƒ€ì…ì´ë©´ ì´ ì½”ë“œë§Œ ìƒì„±
    }
}

// ì‚¬ìš©
process(10);        // sizeof(int) <= 8 â†’ process_smallë§Œ ì»´íŒŒì¼
process(1.0);       // sizeof(double) == 8 â†’ process_smallë§Œ ì»´íŒŒì¼
process(BigObj());  // sizeof(BigObj) > 8 â†’ process_largeë§Œ ì»´íŒŒì¼
```

**ìƒì„±ë˜ëŠ” ì½”ë“œ:**
```cpp
// process(10) í˜¸ì¶œ ì‹œ ì‹¤ì œ ìƒì„±ë˜ëŠ” ì½”ë“œ
void process(int value) {
    process_small(value);  // ifë¬¸ ì—†ìŒ!
}
```

#### ì‹¤ì „ ì˜ˆì‹œ 3: í…œí”Œë¦¿ ë©”íƒ€í”„ë¡œê·¸ë˜ë°

```cpp
// ì»´íŒŒì¼ íƒ€ì„ í”¼ë³´ë‚˜ì¹˜
template<int N>
struct Fibonacci {
    static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};

template<>
struct Fibonacci<0> {
    static constexpr int value = 0;
};

template<>
struct Fibonacci<1> {
    static constexpr int value = 1;
};

// ì‚¬ìš©
constexpr int fib10 = Fibonacci<10>::value;  // ì»´íŒŒì¼ ì‹œ 55ë¡œ ê³„ì‚°ë¨

// ì»´íŒŒì¼ëŸ¬ê°€ ìƒì„±í•˜ëŠ” ì½”ë“œ:
// constexpr int fib10 = 55;  (ê³„ì‚° ê³¼ì • ì—†ìŒ!)
```

#### í•µì‹¬ í‚¤ì›Œë“œ
- `constexpr`: ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ ë° í•¨ìˆ˜
- `if constexpr`: ì»´íŒŒì¼ íƒ€ì„ ë¶„ê¸°
- `consteval` (C++20): ë¬´ì¡°ê±´ ì»´íŒŒì¼ íƒ€ì„ë§Œ
- í…œí”Œë¦¿ ë©”íƒ€í”„ë¡œê·¸ë˜ë°: íƒ€ì… ê³„ì‚°

---

### ğŸ¯ 9.3 ë©”ëª¨ë¦¬ ì§€ì—­ì„± (ìƒì„¸)

#### í•µì‹¬ ê°œë…
**"ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ ìƒì—ì„œ ê°€ê¹ê²Œ ë°°ì¹˜í•˜ì—¬ CPU ìºì‹œ íˆíŠ¸ìœ¨ì„ ë†’ì¸ë‹¤"**

#### CPU ìºì‹œ êµ¬ì¡°

```
CPU
â”œâ”€ L1 ìºì‹œ (32KB, 1 ì‚¬ì´í´)   â† ê°€ì¥ ë¹ ë¦„
â”œâ”€ L2 ìºì‹œ (256KB, 4 ì‚¬ì´í´)
â”œâ”€ L3 ìºì‹œ (8MB, 40 ì‚¬ì´í´)
â””â”€ RAM (16GB, 200 ì‚¬ì´í´)      â† ê°€ì¥ ëŠë¦¼

ì†ë„ ì°¨ì´: L1 vs RAM = 200ë°°!
```

#### ì‹¤ì „ ì˜ˆì‹œ 1: ì—°ì† ë©”ëª¨ë¦¬ (vector vs list)

```cpp
// âŒ ë¹„ì—°ì† ë©”ëª¨ë¦¬ (list) - ìºì‹œ ë¯¸ìŠ¤ ë¹ˆë²ˆ
std::list<int> data;
for (int i = 0; i < 1000000; ++i) {
    data.push_back(i);
}

// ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:
// [ë…¸ë“œ1: 0x1000] â†’ [ë…¸ë“œ2: 0x5000] â†’ [ë…¸ë“œ3: 0x2000] (ì‚°ì¬)
//         â†“                â†“                â†“
//    ìºì‹œ ë¯¸ìŠ¤        ìºì‹œ ë¯¸ìŠ¤         ìºì‹œ ë¯¸ìŠ¤

// âœ… ì—°ì† ë©”ëª¨ë¦¬ (vector) - ìºì‹œ íˆíŠ¸ìœ¨ ë†’ìŒ
std::vector<int> data;
data.reserve(1000000);
for (int i = 0; i < 1000000; ++i) {
    data.push_back(i);
}

// ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:
// [0][1][2][3][4][5][6][7]... (ì—°ì†)
//  â†“  â†“  â†“  â†“
// í•œ ë²ˆì— ìºì‹œë¡œ ë¡œë“œ â†’ ìºì‹œ íˆíŠ¸!
```

**ì„±ëŠ¥ ì¸¡ì •:**
```cpp
// ìˆœì°¨ ì ‘ê·¼ ì„±ëŠ¥
std::list<int> lst(1000000);
auto start = now();
for (auto& x : lst) {
    sum += x;  // ì•½ 50ms
}

std::vector<int> vec(1000000);
auto start = now();
for (auto& x : vec) {
    sum += x;  // ì•½ 5ms (10ë°° ë¹ ë¦„!)
}
```

#### ì‹¤ì „ ì˜ˆì‹œ 2: êµ¬ì¡°ì²´ ì •ë ¬ (íŒ¨ë”© ìµœì†Œí™”)

```cpp
// âŒ ë¹„íš¨ìœ¨ì  ì •ë ¬ (íŒ¨ë”© ë°œìƒ)
struct Bad {
    char a;    // 1 byte
    // [3 byte íŒ¨ë”©]
    int b;     // 4 bytes
    char c;    // 1 byte
    // [3 byte íŒ¨ë”©]
};  // ì´ 12 bytes

// 1000ê°œ ë°°ì—´ = 12KB (íŒ¨ë”© 6KB ë‚­ë¹„)

// âœ… íš¨ìœ¨ì  ì •ë ¬ (íŒ¨ë”© ìµœì†Œí™”)
struct Good {
    int b;     // 4 bytes
    char a;    // 1 byte
    char c;    // 1 byte
    // [2 byte íŒ¨ë”©]
};  // ì´ 8 bytes

// 1000ê°œ ë°°ì—´ = 8KB (íŒ¨ë”© 2KBë§Œ ë°œìƒ, 33% ì ˆì•½)
```

**ìºì‹œ ë¼ì¸ í™œìš©:**
```
ìºì‹œ ë¼ì¸ í¬ê¸°: 64 bytes

Bad êµ¬ì¡°ì²´:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bad(12B)   â”‚ Bad(12B)   â”‚ Bad(12B)   â”‚ Bad(12B)   â”‚ Bad(12B)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   5ê°œ ë¡œë“œ (íŒ¨ë”© í¬í•¨)

Good êµ¬ì¡°ì²´:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Good(8B)â”‚Good(8B)â”‚Good(8B)â”‚Good(8B)â”‚Good(8B)â”‚Good(8B)â”‚Good(8B)â”‚Good(8B)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   8ê°œ ë¡œë“œ (60% ë” ë§ì€ ë°ì´í„°!)
```

#### ì‹¤ì „ ì˜ˆì‹œ 3: AoS vs SoA (Array of Structs vs Struct of Arrays)

```cpp
// âŒ AoS (Array of Structs) - ìºì‹œ ë¹„íš¨ìœ¨
struct Particle {
    float x, y, z;      // ìœ„ì¹˜
    float vx, vy, vz;   // ì†ë„
};

std::vector<Particle> particles(1000);

// x ì¢Œí‘œë§Œ ì—…ë°ì´íŠ¸í•  ë•Œ
for (auto& p : particles) {
    p.x += p.vx;  // 24ë°”ì´íŠ¸ ì¤‘ 8ë°”ì´íŠ¸ë§Œ ì‚¬ìš© (ë‚­ë¹„!)
}

// ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:
// [x|y|z|vx|vy|vz][x|y|z|vx|vy|vz][x|y|z|vx|vy|vz]...
//  â†‘              â†‘              â†‘
// í•„ìš”            ë¶ˆí•„ìš”          í•„ìš”

// âœ… SoA (Struct of Arrays) - ìºì‹œ íš¨ìœ¨
struct Particles {
    std::vector<float> x, y, z;      // ìœ„ì¹˜
    std::vector<float> vx, vy, vz;   // ì†ë„
};

Particles particles;
particles.x.resize(1000);
particles.vx.resize(1000);

// x ì¢Œí‘œë§Œ ì—…ë°ì´íŠ¸í•  ë•Œ
for (size_t i = 0; i < 1000; ++i) {
    particles.x[i] += particles.vx[i];  // í•„ìš”í•œ ë°ì´í„°ë§Œ!
}

// ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:
// x:  [x0|x1|x2|x3|...]  â† ì—°ì†ì , ìºì‹œ íš¨ìœ¨ 100%
// vx: [vx0|vx1|vx2|vx3|...]
```

**ì„±ëŠ¥ ë¹„êµ:**
```cpp
// AoS: ì•½ 15ms (y, z, vy, vzë„ ìºì‹œë¡œ ë¡œë“œí•˜ëŠë¼ ë‚­ë¹„)
// SoA: ì•½ 5ms (x, vxë§Œ ë¡œë“œ, 3ë°° ë¹ ë¦„!)
```

#### ì‹¤ì „ ì˜ˆì‹œ 4: ìˆœì°¨ ì ‘ê·¼ vs ëœë¤ ì ‘ê·¼

```cpp
std::vector<int> data(1000000);

// âŒ ëœë¤ ì ‘ê·¼ (ìºì‹œ ë¯¸ìŠ¤ ë¹ˆë²ˆ)
for (int i = 0; i < 1000000; ++i) {
    int idx = random() % 1000000;  // ì˜ˆì¸¡ ë¶ˆê°€
    sum += data[idx];
}
// ì‹œê°„: ì•½ 80ms

// âœ… ìˆœì°¨ ì ‘ê·¼ (í”„ë¦¬í˜ì¹˜ íš¨ê³¼)
for (int i = 0; i < 1000000; ++i) {
    sum += data[i];  // ìˆœì°¨ì 
}
// ì‹œê°„: ì•½ 5ms (16ë°° ë¹ ë¦„!)
```

**í”„ë¦¬í˜ì¹˜ íš¨ê³¼:**
```
ìˆœì°¨ ì ‘ê·¼ ì‹œ:
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚  i  â”‚ i+1 â”‚ i+2 â”‚ i+3 â”‚  â† CPUê°€ ë¯¸ë¦¬ ì˜ˆì¸¡í•´ì„œ ë¡œë“œ
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
í˜„ì¬ ì ‘ê·¼    ë¯¸ë¦¬ ë¡œë“œë¨ (í”„ë¦¬í˜ì¹˜)
```

---

## ğŸ“Š í•µì‹¬ ì›ì¹™ í†µí•© ë¹„êµ

| ì›ì¹™ | ëª©í‘œ | ì£¼ìš” ê¸°ë²• | ì„±ëŠ¥ í–¥ìƒ | ì ìš© ë‚œì´ë„ |
|-----|------|----------|----------|-----------|
| **Zero-Cost Abstraction** | ì¶”ìƒí™” ë¹„ìš© ì œê±° | í…œí”Œë¦¿, ì¸ë¼ì¸, constexpr | ~50% | ğŸŸ¢ ì‰¬ì›€ |
| **ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚°** | ëŸ°íƒ€ì„ ë¹„ìš© ì œê±° | constexpr, if constexpr, ë©”íƒ€í”„ë¡œê·¸ë˜ë° | ~100ë°° | ğŸŸ¡ ë³´í†µ |
| **ë©”ëª¨ë¦¬ ì§€ì—­ì„±** | ìºì‹œ íˆíŠ¸ìœ¨ í–¥ìƒ | vector ìš°ì„ , êµ¬ì¡°ì²´ ì •ë ¬, SoA | ~10ë°° | ğŸŸ¢ ì‰¬ì›€ |

---

## ğŸ’¡ ì‹¤ì „ ì ìš© 3ë‹¨ê³„

### 1ë‹¨ê³„: ë©”ëª¨ë¦¬ ì§€ì—­ì„± (ì¦‰ì‹œ ì ìš© ê°€ëŠ¥)
```cpp
// list â†’ vector êµì²´
std::vector<int> data;  // ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ìµœì 
data.reserve(ì˜ˆìƒí¬ê¸°);  // ì¬í• ë‹¹ ë°©ì§€
```

### 2ë‹¨ê³„: Zero-Cost Abstraction (ì½”ë”© ìŠµê´€)
```cpp
// ë²”ìœ„ ê¸°ë°˜ for, STL ì•Œê³ ë¦¬ì¦˜ ì ê·¹ í™œìš©
for (const auto& item : vec) { /* ... */ }
std::sort(vec.begin(), vec.end());
```

### 3ë‹¨ê³„: ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚° (ê³ ê¸‰)
```cpp
// ìƒìˆ˜ëŠ” constexprë¡œ
constexpr int MAX_SIZE = 1000;
// í•¨ìˆ˜ë„ constexprë¡œ
constexpr int compute() { return ...; }
```

---

## ğŸ“ ê²°ë¡ 

í˜„ëŒ€ C++ì˜ ì„±ëŠ¥ ìµœì í™”ëŠ” **"ë¶ˆí•„ìš”í•œ ê°ì²´ ìƒì„±ì„ ìµœì†Œí™”"**í•˜ëŠ” ê²ƒì´ í•µì‹¬ì…ë‹ˆë‹¤.

### ê¸°ì–µí•  í•µì‹¬ 3ê°€ì§€

1. **emplace > move > copy** (ê°ì²´ ìƒì„± ìµœì†Œí™”)
2. **ì°¸ì¡° ì „ë‹¬ > ê°’ ì „ë‹¬** (ë³µì‚¬ ë¹„ìš© ì œê±°)
3. **vector ìš°ì„ ** (ìºì‹œ ì¹œí™”ì )

ì´ ì›ì¹™ë“¤ì„ ë”°ë¥´ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ê³ ì„±ëŠ¥ C++ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€

---

**ì‘ì„±ì¼**: 2025ë…„  
**ë²„ì „**: 1.1  
**ëŒ€ìƒ**: C++11/14/17/20
